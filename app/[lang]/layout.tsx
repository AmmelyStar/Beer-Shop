// app/[lang]/layout.tsx

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "../globals.css";

import Header from "../components/Header";
import { ClerkProvider } from "@clerk/nextjs";
import { enUS, fiFI, ukUA, ruRU } from "@clerk/localizations";
import { etEE } from "@/app/i18n/clerk-et";

// ─────────────────────────────────────────────
// Шрифты
// ─────────────────────────────────────────────
const geistSans = Geist({ variable: "--font-geist-sans", subsets: ["latin"] });
const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

// ─────────────────────────────────────────────
// Локали и типы
// ─────────────────────────────────────────────
const LOCALES = ["en", "et", "fi", "uk", "ru"] as const;
export type Locale = (typeof LOCALES)[number];

type ClerkLocale = typeof enUS;

const MAP: Record<Locale, ClerkLocale> = {
  en: enUS,
  et: etEE,
  fi: fiFI,
  uk: ukUA,
  ru: ruRU,
};

// Тип структуры всех сообщений по образцу en.json
type AllMessages = typeof import("../messages/en.json");

// ─────────────────────────────────────────────
/** Статические импорты словарей */
import en from "../messages/en.json";
import et from "../messages/et.json";
import fi from "../messages/fi.json";
import uk from "../messages/uk.json";
import ru from "../messages/ru.json";

/** Разрешаем неполные словари для локалей */
const DICTS: Record<Locale, Partial<AllMessages>> = {
  en,
  et,
  fi,
  uk,
  ru,
};

// ─────────────────────────────────────────────
// Типобезопасный deepMerge ТОЛЬКО для plain-objects
// (словари переводов у нас объектные; массивы не поддерживаем — и это ок)
// ─────────────────────────────────────────────
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends Record<string, unknown>
    ? DeepPartial<T[K]>
    : T[K];
};

function isPlainObject(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}

function deepMerge<T extends Record<string, unknown>>(
  base: T,
  patch?: DeepPartial<T>
): T {
  if (!patch) return base;

  // Поверхностная копия базы (обязательно объект, не массив)
  const result: Record<string, unknown> = { ...base };

  for (const key of Object.keys(patch as Record<string, unknown>)) {
    const k = key as keyof T;
    const pv = (patch as Record<string, unknown>)[key];

    if (pv === undefined) continue;

    const bv = base[k];

    if (isPlainObject(bv) && isPlainObject(pv)) {
      // Оба plain-object — мержим рекурсивно
      (result as T)[k] = deepMerge(
        bv as Record<string, unknown>,
        pv as DeepPartial<Record<string, unknown>>
      ) as unknown as T[typeof k];
    } else {
      // Иначе — заменяем значением патча
      (result as T)[k] = pv as T[typeof k];
    }
  }

  return result as T;
}

// ─────────────────────────────────────────────
// Генерация статических параметров
// ─────────────────────────────────────────────
export async function generateStaticParams() {
  return LOCALES.map((lang) => ({ lang }));
}

// ─────────────────────────────────────────────
// Метаданные
// ─────────────────────────────────────────────
export const metadata: Metadata = {
  title: {
    default: "Create Next App",
    template: "%s | Create Next App",
  },
  description: "Generated by create next app",
};

// ─────────────────────────────────────────────
// RootLayout
// ─────────────────────────────────────────────
export default async function RootLayout({
  children,
  params,
}: Readonly<{ children: React.ReactNode; params: { lang: Locale } }>) {
  const { lang } = params;

  // Берём частичный словарь для выбранного языка и глубоко мержим с en
  const messages = deepMerge<AllMessages>(
    en as AllMessages,
    DICTS[lang] as DeepPartial<AllMessages>
  );

  return (
    <html lang={lang}>
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <ClerkProvider localization={MAP[lang]}>
          <Header lang={lang} messages={messages} />
          {children}
        </ClerkProvider>
      </body>
    </html>
  );
}
